# Object Discussions

## Chapter 04, 설계 품질과 트레이드오프 (Design quality and Trade off)

### Discussion 01 - Data oriented?

훌륭한 객체지향 설계는 데이터가 아니라 책임에 초점을 맞춰야 한다는 온전히 객체지향적인 설계 과정에서만 맞는 말일 수 있다.
객체지향적일 필요가 없는 문제가 그런 프로젝트에서는 데이터 중심과 그 처리 과정이 중요할 수 있다.

예) IoT 센서를 통해 받아온 날씨 데이터를 시각화 하는 문제를 해결하는데 객체지향까지 동원될 필요가 있을까? 하는 의문.
물론 객체지향을 적용할 수 있지만 도메인 모델이 너무 단순하기 때문에 이런 문제까지 객체지향을 적용하는게 맞을지는 의문이다.

다시 돌아와서, 영화 예매 시스템의 경우는 단순한 도메인 모델이 아니므로 충분히 객체지향적인 설계가 필요하며 지향해야 한다는 점에서는 매우 동의한다.

그럼에도 불구하고 저자는 데이터 중심의 설계가 객체지향적인 문제를 해결하고자 하는데 문제가 뭔지에 대해서 얘기하는 걸 보면 객체지향에 대한 매우 깊은 이해가 있다는 걸 역으로 짐작해 볼 수 있다. 이게 읽는 사람에 따라 어떻게 느껴지는지에 대해 의견을 나눌 필요 있음.

### Discussion 02 - Type dependency

예제에 movieType이 등장하는데 이걸 보고 느낀건 나도 종종 이런 식으로 데이터를 중심으로 type을 분류해 switch case문으로 구분해서 별도의 로직을 코드로 작성했던 적이 많다는 것이다.

그리고 책에 있는 내용을 보자마자, `아! 이걸 상속을 통한 overriding으로 했으면 깔끔했을텐데!`를 알아차리게 됐다.

class 코드를 수십개를 만들어내면서 정작 type별 분류, 아니 enum으로라도 만들면 다행이다. int 변수로 0, 1, 2로 구분해서 if, if else, else 문으로 했던 적이 있던가? 그랬다면 그 흑역사에 대해 논의해볼 필요가 있어 보인다.

### Discussion 03 - All business logic in one method

아니나 다를까 `영화를 예매하자` 단락에 ReservationAgency라는 그럴싸한 class가 준비되어 있고 내가 예상했던 if, if else, else, switch case문의 향연이 단 하나의 메소드인 reserve에 준비되어 있다 으하하하!

혹시 자신이 짠 코드가 이랬던 적이 있었던가? 나는 솔직히 있다. 왜 이런 procedural code가 나오는지 역시 논의를 할 필요가 있다. 데이터 중심이라면 반드시 그 데이터를 처리해야 하는 함수 기반의 로직 처리가 길게 나오는게 필연적이기 때문이다.

이럴꺼면 그냥 함수로 만들지 ReservationAgency라는 클래스는 그냥 이름뿐인 클래스인듯하다. 만약 이런 클래스를 만들고 객체지향적으로 짰다고 하면 아직 객체지향을 많이 배워야 하지 않을까? 싶다.

### Discusion 04 - Again encapsulation

인터페이스의 중요성이 다시 한번 강조된다.

> 변경될 가능성이 높은 부분을 **구현**이라고 부르고 상대적으로 안정적인 부분을 **인터페이스**라고 부른다는 사실을 기억하라.

너무나도 공감되는 말이다. 인터페이스가 가지는 어떤 역할을 정말 잘 생각해 보면 객체지향을 언급하는데 정말 빠질 수 없는 녀석이라고 확신할 수 있다.

나도 돌이켜 보면, 어떻게든 인터페이스를 적용하려고 의식적으로 코딩을 하다 보면, 결국 어떤 설계를 해야 하는지 그림을 그리게 되고 인터페이스를 통한 객체의 자율성의 보장은 다른 객체들과의 원활한 협력을 가능하게 하는 것 같다.

솔직히 잘 만든 인터페이스 하나가 어떤 파장을 불러 오는지 경험한게 있다면 얘기해 보면 좋을 것 같다. 이게 논의 포인트.

### Discussion 05 - cohesion, coupling and deisgn

응집도와 결합도에 대한 얘기는 사실 많이 들어본 얘기일 것이다. 그런데 실제 자신의 코드에 `이건 응집도가 낮아요`, `이건 결합도가 높아요` 이런 식으로 못 짠 코드에 대해 얘기하지 못한다.

또 `응집도와 결합도를 고려해서 코드를 짰다`라고 해서 보면 그게 얼마나 맞는 말인지 누가 판단해줄 근거도 없고 그냥 도시전설 같은 이야기인것만 같다.

하지만 보통은 응집도가 높게는 짤 수 있다고 믿는데, 결합도에 대해서는 쉽게 얘기하지 못하는 부분을 많이 발견한다. 왜일까? 그건 인터페이스에 대한 이해도가 현저히 부족해서 생기는 결과라고 본다.

이것도 결국 설계 문제로 귀결되는데, 저자의 뼈 있는 한 마디가 심금을 울리는 듯 하다.

> 응집도와 결합도의 의미를 이해하기 위한 첫걸음은 두개념 모두 설계와 관련 있다는 사실을 이해하는 것이다.

역시 기승전설계? 인듯 한데, 다시 설계에 대해 생각해 보고 논의할 필요가 있다고 봄.

### Discussion 06 - SRP, Single Responsibility Principle

단일 책임의 원칙은 응집도가 높은 설계의 원칙임

아무것도 모르고 보면 그저 좋은 말 같다.

우리는 SOLID 중, S에 해당하는 단일 책임의 원칙을 잘 지키고 있었는지 논의해볼 필요가 있다.

그저 프로젝트 마감 때문에, 동작만 하면 되기 때문에, 시간이 없기 때문에라는 좋은 핑계거리를 두고 좋은 코드를 작성하기 위한 의무를 져버리지 않았는지 반성도 해봤으면 좋겠다.

### Discussion 07 - Review encapsulation

Rectangle class의 예제는 너무 이상적이다. 구현에 집중하면 객체지향의 원칙이 캡슐화에 대한 원칙 역시 지킬 수 없을 것이다.

enlarge라는 메소드를 생각할 수 있으려면, 정말 객체지향을 생각해야 하는데 구현에 집중한다면 아마 책의 예제처럼 AnyClass.anyMethod()와 같은 일이 계속해서 벌어질 것이다.

class 코드를 작성했던 때를 떠올려 보고 책의 예제인 Reactangle과 같은 코드를 짜본 적이 있는지? 논의해 봤으면 좋겠다.

### Disscussion 08 - Problem of data driven design

데이터 중심 설계의 문제점에 대해 두 문장으로 요약이 되었다

> 데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.\
데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

이게 어떤 의미인지 자세한 토론을 해봤으면 좋겠다. 이미 잘못된 설계의 예제와 문제점, 약간의 해결책이 진행 되었으므로 느낀점을 얘기해봐도 좋을 것 같다.

두번째 문장은 `어떤 객체도 섬이 아니다`라는 얘기와 일맥상통하는 말로 강하게 다가온다. 고립 == 섬. 와닿지 않을까?